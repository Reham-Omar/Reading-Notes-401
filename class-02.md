 # Classes, Inheritance, Functional Programming

 
## Inheriting properties :

- JavaScript does not have "methods" in the form that class-based languages define them. 
 In JavaScript, any function can be added to an object in the form of a property.
- An inherited function acts just as any other property.

## classes

Classes are in fact "special functions", the class syntax has two components:
1. class expressions : It can be named or unnamed. The name given to a named class expression is local to the class's body.
*unnamed*

```
let Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  console.log(Rectangle.name);

};
``` 


*named*

```
let Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  console.log(Rectangle.name);

};
```

2. class declarations :use the class keyword with the name of the class
``` class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

### Class body and method definitions

1. Strict mode
The body of a class is executed in strict mode,

2. Constructor
The constructor method is a special method for creating and initializing an object created with a class.

3. Prototype methods 
4. Static methods
The static keyword defines a static method for a class.
It used to create utility functions for an application.

### this 

A function's this keyword behaves a little differently in JavaScript compared to other languages. It also has some differences between strict mode and non-strict mode.

In most cases, the value of this is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called.

## Functional Programming :

- Functional programming is about modeling your solution as pure functions.
- Functional programming means programming with a distinction between pure code and impure code.

- The distinction between pure code and impure code uniquely identifies functional programming and distinguishes it from other paradigms such as procedural and Object Oriented.

- Pure code has no side effects. Itâ€™s referentially transparent. It means the same results every time you run it.

- Impure code contains side effects, so running it twice is different from running it once.

## Errors

Applications running in Node.js will generally experience four categories of errors:
1. Standard JavaScript errors 
2. System errors triggered by underlying operating system constraints
3.  User-specified errors triggered by application code
4. Assertion Errors

- A generic JavaScript Error object that does not denote any specific circumstance of why the error occurred. 
- Error objects capture a "stack trace" detailing the point in the code at which the Error was instantiated, and may provide a text description of the error.

All errors generated by Node.js, including all System and JavaScript errors, will either be instances of, or inherit from, the Error class.

## Higher-Order Functions

Higher-Order function is a function that receives a function as an argument or returns the function as output.


```
const arr1 = [1, 2, 3];
const arr2 = arr1.map(function(item) {
  return item * 2;
});
console.log(arr2);

```
## Jest :
Jest is a JavaScript test runner, that is, a JavaScript library for creating, running, and structuring tests. Jest is distributed as an NPM package, you can install it in any JavaScript project. Jest is one of the most popular test runner these days and the default choice for Create React App.

## Test-Driven Development

- It's is a process of developing and running automated test before actual development of the application .
- It's starts with designing and developing tests for every small functionality of an application.

**Advantages**
1. let the developers to create small and testable features.
2. TDD can speed up development time. 
3. validate the integrity of the new code. 4.help developers understand their goals.

### beforeEach and afterEach

The beforeEach and afterEach commands allow you to define setup and teardown tasks that are performed at **the beginning and end of every It block**.
- This can eliminate duplication of code in test scripts, and perform any necessary cleanup tasks after each test. 
- beforeEach and afterEach blocks may be defined inside of any Describe or Context.